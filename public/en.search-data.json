{"/documentation/":{"data":{"":"With the GenHTTP framework, developers should be able to easily develop new web services in a short time. Everything else is provided by the server infrastructure as well as the excellent ecosystem of .NET which easily allows to build, test, and run applications.\nSimilar to other frameworks such as Nancy, embedio, NetCoreServer, or Watson, and in comparison to ASP.NET, GenHTTP focuses on a low learning curve to quickly achieve results. You should be able to setup a new web service or website in a couple of minutes.","getting-started#Getting Started":"This section shows how to create a new project from scratch using project templates and how to extend your existing application by embedding the GenHTTP engine.\nNew Project Project templates can be used to create apps for typical use cases with little effort. After installing the .NET SDK and the templates via dotnet new -i GenHTTP.Templates in the terminal, the templates are available via the console or directly in Visual Studio:\nTo create a project by using the terminal, create a new folder for your app and use one of the following commands:\nTemplate Command Documentation REST Webservice dotnet new genhttp-webservice Webservices REST Webservice (single file) dotnet new genhttp-webservice-minimal Functional Handlers Website (Static HTML) dotnet new genhttp-website-static Statics Websites Single Page Application (SPA) dotnet new genhttp-spa Single Page Applications (SPA) After the project has been created, you can run it via dotnet run and access the server via http://localhost:8080.\nExtending Existing Apps If you would like to extend an existing .NET application, just add a nuget reference to the GenHTTP.Core nuget package. You can then spawn a new server instance with just a few lines of code:\nvar content = Content.From(Resource.FromString(\"Hello World!\")); using var server = Host.Create() .Handler(content) .Defaults() .Start(); // or .Run() to block until the application is shut down When you run this sample it can be accessed in the browser via http://localhost:8080.","next-steps#Next Steps":"The example project above gives you a basic idea on how projects developed with the GenHTTP may look like. To create more complex web applications (such as webservices), follow the guides in the following sections:\nProviding Content Testing Server Setup Hosting Apps "},"title":"Documentation"},"/documentation/content/":{"data":{"":"","application-frameworks#Application Frameworks":"","concepts#Concepts":"Starting a GenHTTP server instance will always require you to specify the handler that is responsible to generate responses to client requests. Depending on the kind of content you would like to serve (such as a webservice), there are various handlers already available to be used.\nHost.Create() .Handler(...) .Run(); You will typically start with a layout that allows to structure your web application and add the handlers needed to achieve the required functionality to this layout.\nThis page lists all handlers that are provided by the framework. To implement new functionality, you can also implement custom handlers.\nTo create a new project from scratch, it is recommended to use a project template.\nApplication Frameworks Webservices\rFunctional Handlers\rControllers\rStatic Websites\rSingle Page Applications (SPA)\rConcerns Authentication\rClient Caching (Policy)\rClient Caching (Validation)\rCompression\rCORS\rError Handling\rServer Caching\rRange Support\rDefaults\rProviders Layouting\rStatic Content\rDownloads\rRedirects\rDirectory Browsing\rReverse Proxies\rVirtual Hosts\rLoad Balancer\rConcepts Method Definitions\rResources\rCaches","concerns#Concerns":"","providers#Providers":""},"title":"Content"},"/documentation/content/concepts/":{"data":{"":"","concepts#Concepts":"This page lists shared concepts or mechanisms that are used across various handlers.\nConcepts Method Definitions\rResources\rCaches"},"title":"Concepts"},"/documentation/content/concepts/caches/":{"data":{"":"Caches can be used by handlers such as the cached content concern to store and serve intermediate results for improved performance. The SDK ships with backends for local memory and file system based storage. Custom backends can be provided by implementing the ICache interface.\nvar memoryCache = Cache.Memory\u003cMyClass\u003e(); var tempFileCache = Cache.TemporaryFiles\u003cMyClass\u003e(); var persistentFileCache = Cache.FileSystem\u003cMyClass\u003e(\"./cache\"); "},"title":"Caches"},"/documentation/content/concepts/definitions/":{"data":{"":"","injection#Injection":"","registries#Registries":"All API frameworks share a common base provided by the Reflection and Conversion modules which define some of the capabilities that can be used when defining an API method signature.\nInjection This section describes how parameters of your methods are initialized and which kind of types can be used.\nPrimitives By default, the following types can be used as parameters within a method definition: string, bool, enum, Guid, DateOnly and any other primitive type (such as int).\nWebservicesFunctionalControllers [ResourceMethod] public int Length(string text) =\u003e text.Length; .Get((string text) =\u003e text.Length) public int Index(string text) =\u003e text.Length; Parameters can be declared nullable (e.g. int?) and will be initialized with null if not present. If not declared nullable, parameters will be initialized with default(T) if not present.\nBy default, parameters are read from the request query (?text=abc) or from a form encoded body.\nIf you would like to read the parameter directly from the request body, you can mark it with the [FromBody] attribute.\nWebservicesFunctionalControllers [ResourceMethod(RequestMethod.PUT)] public int Length([FromBody] string text) =\u003e text.Length; .Put(([FromBody] string text) =\u003e text.Length) [ControllerAction(RequestMethod.PUT)] public int Index([FromBody] string text) =\u003e text.Length; To read the parameter from the request path, use the appropriate method provided by the application framework.\nWebservicesFunctionalControllers [ResourceMethod(RequestMethod.DELETE, \":id\")] public void Delete(int id) { /* ... */ } .Delete(\"/:id\", (int id) =\u003e { /* ... */ }) [ControllerAction(RequestMethod.DELETE)] public int Delete([FromPath] int id) { /* ... */ } Some frameworks allow to further restrict path parameters using a regular expression.\nWebservicesFunctional [ResourceMethod(\"(?\u003cean13\u003e[0-9]{12,13})\")] public Book? GetBook(int ean13) { /* ... */ } .Get(\"/books/?\u003cean13\u003e[0-9]{12,13})\", (int ean13) =\u003e { /* ... */ }) Complex Types When using a complex type in a parameter declaration, the value will be deserialized from the request body. By default, handlers will accept content declared as XML, JSON or form encoded. If the client does not declare the Content-Type, the server will try to treat the body as JSON.\nWebservicesFunctionalControllers [ResourceMethod(RequestMethod.POST)] public void Save(MyClass data) { /* ... */ } .Post((MyClass data) =\u003e { /* ... */ }) [ControllerAction(RequestMethod.POST)] public void Save(MyClass data) { /* ... */ } HTML Forms Form data can be used to populate both complex types and primitive parameters. Browsers will encode the content as application/x-www-form-urlencoded and the framework will populate the arguments as needed. This allows such endpoints to be used both from browsers and as a regular API.\nExample form:\n\u003cform action=\"/save\" method=\"post\"\u003e \u003clabel for=\"id\"\u003eID:\u003c/label\u003e \u003cinput type=\"number\" id=\"id\" name=\"id\" required\u003e \u003cbr\u003e\u003cbr\u003e \u003clabel for=\"name\"\u003eName:\u003c/label\u003e \u003cinput type=\"text\" id=\"name\" name=\"name\" required\u003e \u003cbr\u003e\u003cbr\u003e \u003cinput type=\"submit\" value=\"Submit\"\u003e \u003c/form\u003e Can be read using the following definitions:\nWebservicesFunctionalControllers [ResourceMethod(RequestMethod.POST)] public void Save(int id, string name) { /* ... */ } // or [ResourceMethod(RequestMethod.POST)] public void Save(MyRecord record) { /* ... */ } .Post(\"/save\", (int id, string name) =\u003e { /* ... */ }) // or .Post(\"/save\", (MyRecord data) =\u003e { /* ... */ }) [ControllerAction(RequestMethod.POST)] public void Save(int id, string name) { /* ... */ } // or [ControllerAction(RequestMethod.POST)] public void Save(MyRecord data) { /* ... */ } Both mechanisms can also be mixed (read one argument as a parameter and all others as a custom type).\nRequest Injection To access information about the currently executed request you can add a parameter of type IRequest to your method definition which will automatically be populated.\nWebservicesFunctionalControllers [ResourceMethod] public string? GetUserAgent(IRequest request) =\u003e request.UserAgent; .Get(\"/user-agent\", (IRequest request) =\u003e request.UserAgent) public string? UserAgent(IRequest request) =\u003e request.UserAgent; Injecting requests is required if you would like to generate custom responses.\nIf you frequently access the request in your endpoints to achieve a certain functionality, think about adding custom primitives, custom injectors or a custom concern.\nHandler Injection Similar to request injection you can also inject the IHandler which is responsible for the current request. This is typically not required but can be used to create and return custom requests handlers on the fly.\nStreams The request body can be injected as a Stream, e.g. when implementing file uploads. This stream represents the processed request payload, so it will already be decompressed and not in a chunked format. Depending on the size of request body this will either be a stream backed by memory or by a file and is therefore well suited for very large payloads.\nWebservicesFunctionalControllers [ResourceMethod(RequestMethod.PUT, \"upload\")] public void Upload(Stream file) { /* ... */ } .Put(\"/upload\", (Stream file) =\u003e { /* ... */ }) [ControllerAction(RequestMethod.PUT)] public void Upload(Stream file) { /* ... */ } Custom Injection To inject custom types besides the built-in capabilities, you can configure a custom InjectionRegistry and use it with your API services. The registry accepts IParameterInjector instances that define what types are supported and how they are determined from the current request and environment.\nThe following injector will inspect the requests headers for a correlation ID and create a new one if not present.\npublic record class CorrelationID(string ID); public class CorrelationInjector : IParameterInjector { public bool Supports(Type type) =\u003e type == typeof(CorrelationID); public object? GetValue(IHandler handler, IRequest request, Type targetType) { if (request.Headers.TryGetValue(\"X-Correlation-ID\", out var id)) { return new CorrelationID(id); } return new CorrelationID(Guid.NewGuid().ToString()); } } The injector can than be added to the default injection registry:\nWebservicesFunctionalControllers var injection = Injection.Default() .Add(new CorrelationInjector()); var api = Layout.Create() .AddService\u003cMyService\u003e(\"service\", injection); public class MyService { [ResourceMethod] public string GetCorrelationID(CorrelationID cor) =\u003e cor.ID; } var injection = Injection.Default() .Add(new CorrelationInjector()); var api = Inline.Create() .Injectors(injection) .Get((CorrelationID cor) =\u003e cor.ID); var injection = Injection.Default() .Add(new CorrelationInjector()); var api = Layout.Create() .AddController\u003cMyController\u003e(\"controller\", injection); public class MyController { public string GetCorrelationID(CorrelationID cor) =\u003e cor.ID; } User Injection To inject the authenticated user, you can add a typed injector to your injection registry.\nvar injection = Injection.Default() .Add(new UserInjector\u003cBasicAuthenticationUser\u003e()); Response Generation This section describes the various mechanisms to generate a service response.\nPrimitives By default, the following types can be used as a return type within a method definition: string, bool, enum, Guid, DateOnly and any other primitive type (such as int).\nIf declared nullable, the server will generate a HTTP 204 No Content if null is returned.\nWebservicesFunctionalControllers [ResourceMethod] public int Length(string text) =\u003e text.Length; .Get((string text) =\u003e text.Length) public int Index(string text) =\u003e text.Length; Complex Types When returning a complex type, the value will be serialized and sent to the client. The response format is negated with the client using the Accept request header. By default, the server is capable of generating XML, JSON or form encoded responses. If no format is specified by the client, the implementation will fall back to JSON.\nIf declared nullable, the server will generate a HTTP 204 No Content if null is returned.\nWebservicesFunctionalControllers [ResourceMethod] public MyType DoWork() =\u003e new(); .Get(() =\u003e new MyType()) public MyType Index() =\u003e new(); Custom Responses When injecting the request into your method, you can directly generate an IResponse or IResponseBuilder and return it to the client. This allows you to take full control over the response generation but is less readable than the typed versions.\nWebservicesFunctionalControllers [ResourceMethod] public IResponseBuilder Respond(IRequest request) { var content = Resource.FromString(\"Hello World\") .Build(); return request.Respond() .Header(\"X-My-Header\", \"my-value\") .Content(content) .Type(ContentType.TextPlain); } .Get((IRequest request) =\u003e { var content = Resource.FromString(\"Hello World\") .Build(); return request.Respond() .Header(\"X-My-Header\", \"my-value\") .Content(content) .Type(ContentType.TextPlain); }) public IResponseBuilder Respond(IRequest request) { var content = Resource.FromString(\"Hello World\") .Build(); return request.Respond() .Header(\"X-My-Header\", \"my-value\") .Content(content) .Type(ContentType.TextPlain); } // ToDo: Doku zu möglichen Contents (verlinken bei custom handler?)\nResults Results are type-safe responses that can still be adjusted to modify the generated HTTP response. Therefore, results can be considered an advanced way to generate responses without the need to fully generate the response in the first place.\nWebservicesFunctionalControllers [ResourceMethod] public Result\u003cstring\u003e DoWork() { return new Result\u003cstring\u003e(\"Hello World\").Header(\"X-My-Header\", \"my-value\"); } .Get(() =\u003e new Result\u003cstring\u003e(\"Hello World\").Header(\"X-My-Header\", \"my-value\")) public Result\u003cstring\u003e Index() { return new Result\u003cstring\u003e(\"Hello World\").Header(\"X-My-Header\", \"my-value\"); } The Result\u003cT\u003e class allows to adjust any response property besides the actual content by implementing the same interfaces as the IResponseBuilder. This does not only work for data structures, but also for special types such as streams.\nHandlers Instead of generating a response you can also return an IHandler or IHandlerBuilder instance. This allows you to provide a whole segment on your web application by re-using the existing handlers or by implementing custom ones.\nThe following example will render a fully navigable directory listing view depending on the tenant ID passed to the method:\nWebservicesFunctionalControllers [ResourceMethod(\"files/:tenant\")] public IHandlerBuilder Files(int tenant) { var tree = ResourceTree.FromDirectory($\"/data/tenants/{tenant}\"); return Listing.From(tree); } .Get(\"/files/:tenant\", (int tenant) =\u003e Listing.From(ResourceTree.FromDirectory($\"/data/tenants/{tenant}\"))) public IHandlerBuilder Files(int tenant) { var tree = ResourceTree.FromDirectory($\"/data/tenants/{tenant}\"); return Listing.From(tree); } Streams To return files or similar content, you can directly return a Stream instance from your method. The framework will automatically seek and dispose the stream. Returning streams is not thread-safe as streams are stateful, so you will need to create a new instance for every request to be answered.\nWebservicesFunctionalControllers [ResourceMethod] public Stream GetFile() =\u003e File.OpenRead(\"...\"); .Get(() =\u003e File.OpenRead(\"...\")) public Stream File() =\u003e File.OpenRead(\"...\"); Empty Responses Methods with a void return type will automatically generate a HTTP 204 No Content response. This is also the case when null is returned.\nWebservicesFunctionalControllers [ResourceMethod] public void DoWork() { } .Get(() =\u003e { }}) public void DoWork() { } Asynchronous Execution Service methods returning a Task or ValueTask will be executed asynchronously. All the features described in this document will work for asynchronous execution as well.\nWebservicesFunctionalControllers [ResourceMethod] public async ValueTask\u003cint\u003e DoWork() { /* ... */ } .Get(async () =\u003e await ...) public async ValueTask\u003cint\u003e DoWork() { /* ... */ } Registries This section describes registries that can be used for both injection as well as response generation.\nCustom Primitives Primitives (such as Guid or int) used in parameters or as a response type are automatically handled using the built-in FormatterRegistry. You can add support for a custom type by implementing an IFormatter and adding it to a custom registry which is then used by your services.\nThe following implementation will add support for a Point type with x and y coordinates so it can be used in a service.\npublic record class Point(int X, int Y); public class PointFormatter : IFormatter { public bool CanHandle(Type type) =\u003e type == typeof(Point); public object? Read(string value, Type type) { var parts = value.Split('-'); return new Point(int.Parse(parts[0]), int.Parse(parts[1])); } public string? Write(object value, Type type) { var point = (Point)value; return $\"{point.X}-{point.Y}\"; } } This formatter can then be added to the default formatting registry.\nWebservicesFunctionalControllers var registry = Formatting.Default() .Add(new PointFormatter()); var api = Layout.Create() .AddService\u003cMyService\u003e(\"service\", registry); public class MyService { [ResourceMethod(\"invert/:point\")] public Point Invert(Point point) =\u003e new(point.Y, point.X); } var registry = Formatting.Default() .Add(new PointFormatter()); var api = Inline.Create() .Formatters(registry) .Get(\"/invert/:point\", (Point point) =\u003e new(point.Y, point.X)); var registry = Formatting.Default() .Add(new PointFormatter()); var api = Layout.Create() .AddController\u003cMyController\u003e(\"controller\", registry); public class MyController { public Point Invert([FromPath] Point point) =\u003e new(point.Y, point.X); } The serialization format is implemented by our formatter, so the API can be called via /invert/8-10 and will return 10-8 as a text formatted response.\nSerialization Formats Serialization allows to read and write complex types, so they can be used in your method definitions. By default, services can consume and produce entities in XML, JSON or in form encoding, with a default fallback to JSON.\nWhen sending an entity to your service, the client should specify the Content-Type of the body so the server can choose the correct deserializer to read the data with. The Accept header sent by the client tells the server which serialization format is preferred by the client when a response is generated. The server will tell the client which serialization format was used to generate the body of the response by specifying the Content-Type header again.\nTo add support for an additional format you can implement the ISerializationFormat and add your implementation to a registry which is then passed to your service.\nFor example, the nuget package GenHTTP.Modules.Protobuf adds support for Protocol Buffers which is not enabled by default. The following snippet shows how to register the protobuf format and use it in a service.\nWebservicesFunctionalControllers var registry = Serialization.Default() .Add(new FlexibleContentType(\"application/protobuf\"), new ProtobufFormat()); var api = Layout.Create() .AddService\u003cMyService\u003e(\"service\", registry); public class MyService { [ResourceMethod(RequestMethod.PUT)] public ResponseType Store(RequestType data) { /* ... */ } } var registry = Serialization.Default() .Add(new FlexibleContentType(\"application/protobuf\"), new ProtobufFormat()); var api = Inline.Create() .Serializers(registry) .Put((RequestType data) =\u003e { /* ... */ }); var registry = Serialization.Default() .Add(new FlexibleContentType(\"application/protobuf\"), new ProtobufFormat()); var api = Layout.Create() .AddController\u003cMyController\u003e(\"controller\", registry); public class MyController { [ControllerAction(RequestMethod.PUT)] public ResponseType Store(RequestType data) { /* ... */ } } ","response-generation#Response Generation":""},"title":"Method Definitions"},"/documentation/content/concepts/resources/":{"data":{"":"","resource-trees#Resource Trees":"Resources provide an unified way to load and access binary data used by handlers to achieve their functionality. For example, the Download handler serves a single file on request - where the content of the file originates from is not important for the handler to achieve it’s functionality.\nvar resource = Resource.FromFile(\"/var/www/downloads/myvideo.mp4\"); // or FromString, FromAssembly, ... var download = Download.From(resource); Host.Create() .Handler(download) .Run(); By implementing the IResource interface, a custom data source can be used to provide resources, for example a database or a cloud blob storage.\nResource Trees Similar to the resources, resource trees provide an abstraction for a directory structure that can be consumed by handlers such as the Directory Browsing or the Single Page Application.\nvar tree = ResourceTree.FromDirectory(\"/var/www/downloads/\"); // or FromAssembly, ... var listing = Listing.From(tree); Host.Create() .Handler(listing) .Run(); Virtual trees allow to combine different sources of resources into an unified tree:\nvar tree = VirtualTree.Create() .Add(\"index.html\", Resource.FromFile(...)) .Add(\"config.js\", Resource.FromAssembly(...)) .Add(\"dist\", ResourceTree.FromDirectory(...)); var app = SinglePageApplication.From(tree); "},"title":"Resources"},"/documentation/content/concerns/":{"data":{"":"Concerns allow to add behavior to a section of your web application by intercepting requests and responses. The framework allows any handler to be extended by using concerns. The following example will add a custom HTTP header to every response generated by the server:\npublic class CustomConcern : IConcern { public IHandler Content { get; } public IHandler Parent { get; } public CustomConcern(IHandler parent, Func\u003cIHandler, IHandler\u003e contentFactory) { Parent = parent; Content = contentFactory(this); } public IAsyncEnumerable\u003cContentElement\u003e GetContentAsync(IRequest request) =\u003e Content.GetContentAsync(request); public ValueTask PrepareAsync() =\u003e Content.PrepareAsync(); public async ValueTask\u003cIResponse?\u003e HandleAsync(IRequest request) { var response = await Content.HandleAsync(request); if (response != null) { response.Headers.Add(\"X-Custom-Header\", \"Custom Concern\"); } return response; } } public class CustomConcernBuilder : IConcernBuilder { public IConcern Build(IHandler parent, Func\u003cIHandler, IHandler\u003e contentFactory) { return new CustomConcern(parent, contentFactory); } } var handler = Layout.Create() .Index(Content.From(\"Hello World\")) .Add(new CustomConcernBuilder()); Host.Create() .Handler(handler) .Run(); The GenHTTP SDK uses the same mechanism to achieve functionality such as compression or support for CORS."},"title":"Concerns"},"/documentation/content/concerns/authentication/":{"data":{"":"","api-key-authentication#API Key Authentication":"","basic-authentication#Basic Authentication":"The authentication module allows to restrict access to sections provided by handlers to authenticated users only. Independent from the kind of authentication used, the identified user can be read from the request in the following manner:\nusing GenHTTP.Modules.Authentication; var displayName = request.GetUser\u003cIUser\u003e()?.DisplayName; The user object for the current request will be determined by the installed authentication concern. The concern will allow you to add your custom user object there.\nAPI Key Authentication This kind of authentication requires your clients to authenticate themselves using an key sent with an additional HTTP header (named X-API-Key).\nvar securedContent = Layout.Create(); var auth = ApiKeyAuthentication.Create() .Keys(\"ABC-123\", \"BCD-234\"); securedContent.Authentication(auth); You may customize both where the key is read from and what keys are valid for authentication:\nvar auth = ApiKeyAuthentication.Create() .WithQueryParameter(\"key\") // read the key from the query .. .WithHeader(\"key\") // .. or a custom header ... .Extractor((r) =\u003e ...) // ... or anywhere else .Authenticator(DoAuthenticateAsync); private ValueTask\u003cIUser?\u003e DoAuthenticateAsync(IRequest request, string key) { // do something to check the key (e.g. query a database) return new(new ApiKeyUser(key)); // or null, if no access is granted } Basic Authentication Basic authentication can be used by either specifying a list of users and their passwords or by implementing your custom logic to authenticate and load users (e.g. from a database).\nvar securedContent = Layout.Create(); // specify all users and their password ... var auth = BasicAuthentication.Create() .Add(\"Bob\", \"pw123\") .Add(\"Alice\", \"123pw\"); securedContent.Authentication(auth); // ... or implement your custom logic securedContent.Authentication((user, password) =\u003e { // validate the given credentials here and return your custom user object which needs to implement IUser return new(new BasicAuthenticationUser(user)); }); "},"title":"Authentication"},"/documentation/content/concerns/client-caching-policy/":{"data":{"":"This concern allows to instruct clients to cache responses generated by the server for some duration by adding the Expires HTTP header. The following example will cause the static website to be cached for one week:\nvar website = StaticWebsite.From(...) .Add(ClientCache.Policy().Duration(7)); Host.Create() .Handler(website) .Run(); If needed, a predicate can be passed to specify the content that should be cached more explicitly:\nvar policy = ClientCache.Policy() .Duration(7) .Predicate((req, resp) =\u003e resp.ContentType?.RawType != \"text/html\")); // do not cache HTML pages "},"title":"Client Caching (Policy)"},"/documentation/content/concerns/client-caching-validation/":{"data":{"":"This concern adds an eTag header to every response generated by the server so that clients send a If-None-Match header to validate their cache. If the content did not change on the server, the handler will generate a 304 Not Modified response, causing the client to re-use the locally cached data. This way, clients revisiting your web application load faster and the load on your server is reduced.\nvar content = Layout.Create() .Add(ClientCache.Validation()); The eTag is generated from the checksum of the content that should be served to the client. Dependent on the kind of content (such as a local file resource) the checksum can be calculated quite efficiently.\nThis concern is part of the default configuration and will automatically be added to your server."},"title":"Client Caching (Validation)"},"/documentation/content/concerns/compression/":{"data":{"":"","custom-algorithms#Custom Algorithms":"The compression concern compresses content sent to the clients, if applicable. By default, gzip and Brotli are supported.\nvar content = Layout.Create() .Add(CompressedContent.Default()); This concern is part of the default configuration and will automatically be added.\nCustom Algorithms To add a custom compression algorithm to the server, you can implement the ICompressionAlgorithm interface and register the implementing class with your server builder. For example, the following implementation will add support for the deflate algorithm, which is not provided by the server out of the box:\npublic class DeflateCompression : ICompressionAlgorithm { public string Name =\u003e \"deflate\"; public Priority Priority =\u003e Priority.Low; public IResponseContent Compress(IResponseContent content, CompressionLevel level) { return new CompressedResponseContent(content, (target) =\u003e new DeflateStream(target, level, false)); } } // registration var server = Server.Create() .Handler(...) .Defaults(compression: false) .Compression(CompressedContent.Default().Add(new DeflateCompression())); "},"title":"Compression"},"/documentation/content/concerns/cors/":{"data":{"":"Cross-Origin Resource Sharing allows to control which resources browsers are allowed to access and how they are allowed to do so. For example, if you would like to access a webservice from a website hosted on another domain, the browser will send the Origin header along with requests to the webservice and analyze the response to determine, whether the server allows clients to access the resource from this origin.\nTo allow all clients to access a resource with no restrictions, you can add a Permissive policy to your handler:\nusing GenHTTP.Modules.Webservices; using GenHTTP.Modules.Security; var api = Layout.Create() .AddService\u003cResource1\u003e(\"res1\") .AddService\u003cResource2\u003e(\"res2\") .Add(CorsPolicy.Permissive()); This will set the required headers for requests as well as preflight requests. To restrict the access to a specific origin, create a Restrictive() policy and add the configuration for the desired origin:\nusing GenHTTP.Modules.Webservices; using GenHTTP.Modules.Security; var policy = CorsPolicy.Restrictive() .Add(\"https://mydomain.com\", null, null, null, true); var api = Layout.Create() .AddService\u003cResource1\u003e(\"res1\") .AddService\u003cResource2\u003e(\"res2\") .Add(policy); This way, browsers will deny requests that do not originate from https://mydomain.com. For development purposes, you may combine the snippets above along with the #if DEBUG directive."},"title":"CORS"},"/documentation/content/concerns/defaults/":{"data":{"":"The Defaults() method provided by the Practices module adds some useful concerns to your web server to enable features such as compression or client side caching. This way, you will have a well configured server instance without the need of adding everything by yourself.\nHost.Create() .Handler(...) .Defaults() .Run(); If you would like to opt out of a default feature, you may pass a flag as needed:\nHost.Create() .Handler(...) .Defaults(compression: false) .Run(); "},"title":"Defaults"},"/documentation/content/concerns/error-handling/":{"data":{"":"If an exception occurs while a request is handled, the server will render the exception into a HTML page that informs the client about the issue.\nIf you would like to send cutom HTTP responses for exceptions, you can add the ErrorHandler concern with a custom IErrorMapper.\nThe following example will generate a JSON response for errors and missing content:\nvar errorHandling = ErrorHandler.From(new JsonErrorMapper()); var api = Layout.Create() .AddService\u003c...\u003e() .Add(errorHandling); public record ErrorModel(String Message); public class JsonErrorMapper : IErrorMapper\u003cException\u003e { public ValueTask\u003cIResponse?\u003e GetNotFound(IRequest request, IHandler handler) { var errorModel = new ErrorModel(\"The requested content was not found\"); // hint: return null here to render the default error page of the server return new(GetResponse(request, ResponseStatus.NotFound, errorModel)); } public ValueTask\u003cIResponse?\u003e Map(IRequest request, IHandler handler, Exception error) { var errorModel = new ErrorModel(error.Message); if (error is ProviderException providerException) { return new(GetResponse(request, providerException.Status, errorModel)); } return new(GetResponse(request, ResponseStatus.InternalServerError, errorModel)); } private static IResponse GetResponse(IRequest request, ResponseStatus status, ErrorModel model) { return request.Respond() .Status(status) .Content(new JsonContent(model, new())) .Type(ContentType.ApplicationJson) .Build() } } "},"title":"Error Handling"},"/documentation/content/concerns/range-support/":{"data":{"":"","scope#Scope":"Partial responses allow clients to fetch a specified portion of a requested resource which can be helpful for download managers to pause and resume downloads. As ths functionality is not needed by every web application, range support is disabled by default.\nTo enable this feature on server level, you may pass an additional flag to the default configuration.\nHost.Create() .Handler(...) .Defaults(rangeSupport: true) .Run(); Please note that the implementation does not support multiple ranges to be requested (which would then result in a multipart response).\nScope As the range support is implemented as a concern, you may add this functionality to any handler as needed.\nusing GenHTTP.Modules.IO; var files = ResourceTree.FromDirectory(\"/var/www/downloads\"); layout.Add(\"downloads\", Resources.From(files).AddRangeSupport()); "},"title":"Range Support"},"/documentation/content/concerns/server-caching/":{"data":{"":"","backends#Backends":"","expiration-handling#Expiration Handling":"","filtering#Filtering":"","invalidation#Invalidation":"","pre-compress-content#Pre-compress Content":"This concern allows to cache responses generated by a handler and to serve them from the cache when they are requested again. The following example will cache all responses generated by a website:\nvar website = Website.Create() .Content(...) .Add(ServerCache.Memory()); Host.Create() .Handler(website) .Console() .Defaults() .Run(); When to Cache Caching usually introduces some overhead that might affect the performance of your web application in a negative manner. A cache will boost the performance of your application if the provided content does rarely change and the generation of the content is expensive.\nUsing a file system cache to cache a static website or to cache pages that will change on every request will slow down your application instead.\nBackends The server cache can utilize any backend provided by the cache infrastructure.\n// uses RAM to cache generated responses // trades memory utilization for fast performance var cache = ServerCache.Memory(); // stores generated responses in a temporary directory // uses memory to store the index meta data // low RAM comsumption but way slower than memory var cache = ServerCache.TemporaryFiles(); // stores generated responses in the given directory // can be used to persist the cache across server restarts var cache = ServerCache.Persistent(\"./cache\"); Filtering If you would like to cache only selected responses, you can pass a predicate to select them:\nServerCache.Memory() .Predicate((req, resp) =\u003e resp.ContentType?.KnownType == ContentType.TextHtml); Invalidation By default, the concern will always execute the inner handler to determine, whether the content served by the handler has changed and the cache needs to be updated. If the content generated by your handler is garantueed not to change, you can disable this invalidation to further improve the performance.\nServerCache.Memory() .Invalidate(false); Variations The server cache allows different versions of generated responses to be cached by evaluating the Vary header. For example, if your handler may both return responses compressed with gzip and br, the cache will retain a copy of both versions and evaluate the client headers to server the requested version.\nIf you would like to cache different versions for every user agent, just set the Vary header accordingly:\nrequest.Respond() .Header(\"Vary\", \"User-Agent\"); For more information, see this blog entry.\nExpiration Handling By default, the file system cache will keep discarded entries available for another 30 minutes to allow clients to finish their downloads. If you need to customize this value, you may create a custom instance with a pre-configured cache instead:\nvar meta = Cache.Memory\u003cCachedResponse\u003e(); var data = Cache.TemporaryFiles\u003cStream\u003e() .AccessExpiration(TimeSpan.FromHours(4)); var cache = ServerCache.Create(meta, data); Pre-compress Content Typically, the compression concern is added to dynamically compress the content which is generated by your web application. If the content of your application is rather static, you can use the server cache to compress the content once with a higher compression level. This will result in slightly reduced traffic and greatly reduced CPU usage when serving requests:\nvar compression = CompressedContent.Default() .Level(CompressionLevel.Optimal); var cache = ServerCache.TemporaryFiles() .Invalidate(false); var website = StaticWebsite.From(ResourceTree.FromDirectory(\"/var/www/\")) .Add(compression) .Add(cache); Host.Create() .Handler(website) .Console() .Defaults() .Run(); ","variations#Variations":"","when-to-cache#When to Cache":""},"title":"Server Caching"},"/documentation/content/frameworks/":{"data":{"":"","available-frameworks#Available Frameworks":"Frameworks are regular handlers which allow you to implement your use cases such as providing a RESTful service API.\nAvailable Frameworks Webservices\rFunctional Handlers\rControllers\rStatic Websites\rSingle Page Applications (SPA)"},"title":"Frameworks"},"/documentation/content/frameworks/controllers/":{"data":{"":" GenHTTP.Modules.Controllers This framework allows to create APIs by defining and implementing controller classes. In contrast to ASP.NET you cannot use this framework to dynamically render HTML pages in a MVC style project, so this is just another flavor of defining a web API.\nℹ️ Controller based APIs can quickly be created by using a project template. ","further-resources#Further Resources":"The following capabilities are shared by various application frameworks:\nMethod Definitions ","hosting-an-api#Hosting an API":"The following example shows how an API controlling an IoT device could look like when implemented using the controller framework.\nThe methods of the controller class will automatically be translated into paths that can be called by the client.\n// API will be available via http://localhost:8080/device/ var api = Layout.Create() .AddController\u003cIotController\u003e(\"device\") .Add(CorsPolicy.Permissive()); Host.Create() .Handler(api) .Defaults() .Development() .Console() .Run(); // -- public class IotController { public DeviceInfo Index() { // GET http://localhost:8080/device/ } public DeviceFieldInfo Field([FromPath] int fieldID) { // GET http://localhost:8080/device/field/4711 } [ControllerAction(RequestMethod.POST)] public DeviceInfo Restart() { // POST http://localhost:8080/device/restart } } ","url-patterns#URL Patterns":"The following table shows the rules that are applied to map an URL:\nMethod Endpoint Index() /controller/ Action() /controller/action/ Action([FromPath] int id) /controller/action/:id/ Action(int id) /controller/action/?id=:id LongAction() /controller/long-action/ "},"title":"Controllers"},"/documentation/content/frameworks/functional/":{"data":{"":"","further-resources#Further Resources":"\rGenHTTP.Modules.Functional\rWith this module, requests can be handled in a functional manner, reducing the boilerplate code to be written by a web application developer.\nℹ️ Apps can quickly be created by using a project template. Hosting an API To host an API using this framework you can create an Inline handler and add your operations as needed.\nusing GenHTTP.Engine; using GenHTTP.Modules.Functional; using GenHTTP.Modules.Layouting; var bookService = Inline.Create() // GET http://localhost:8080/books/?page=1\u0026pageSize=20 .Get((int page, int pageSize) =\u003e /* ... */) // GET http://localhost:8080/books/4711 .Get(\":id\", (int id) =\u003e /* ... */) // PUT http://localhost:8080/books/ .Put((Book book) =\u003e /* ... */) // POST http://localhost:8080/books/ .Post((Book book) =\u003e /* ... */) // DELETE http://localhost:8080/books/4711 .Delete(\":id\", (int id) =\u003e /* ... */); var api = Layout.Create() .Add(\"books\", bookService); Host.Create() .Handler(api) .Development() .Console() .Run(); Further Resources The following capabilities are shared by various application frameworks:\nMethod Definitions","hosting-an-api#Hosting an API":""},"title":"Functional Handlers"},"/documentation/content/frameworks/single-page-applications/":{"data":{"":"","hosting-a-spa#Hosting a SPA":"","routing#Routing":"\rGenHTTP.Modules.SPAs\rThis handler provides an easy way to serve a single page application (for example a Vue.js, React, or Angular app) to your clients.\nℹ️ Apps can quickly be created by using a project template. Hosting a SPA var tree = ResourceTree.FromDirectory(\"/var/html/my-webapp\"); var app = SinglePageApplication.From(tree); Host.Create() .Console() .Defaults() .Handler(app) .Run(); This example will automatically search for an index file (such as index.html) in the specified directory and serve it to clients accessing http://localhost:8080/.\nRouting If you would like to use path based routing in your application, the server needs to serve the SPA index for every route. This can be achieved with the ServerSideRouting() method on the SPA builder."},"title":"Single Page Applications (SPA)"},"/documentation/content/frameworks/static-websites/":{"data":{"":"","creating-a-static-website#Creating a Static Website":"\rGenHTTP.Modules.StaticWebsites\rThis handler provides an easy way to serve a static website such as a Hugo application to your clients.\nℹ️ Static websites can quickly be created by using a project template. Creating a Static Website The following example will host the specified application available on http://localhost:8080/.\nvar tree = ResourceTree.FromDirectory(\"/var/html/my-website\"); var app = StaticWebsite.From(tree); Host.Create() .Console() .Defaults() .Handler(app) .Run(); "},"title":"Static Websites"},"/documentation/content/frameworks/webservices/":{"data":{"":"","further-resources#Further Resources":"\rGenHTTP.Modules.Webservices\rThe webservice module provides an easy way to implement RESTful services that can be consumed by clients as needed.\nℹ️ Webservices can quickly be created by using a project template. Hosting an API To host an API using this framework you can define a new class that hosts your operations as dedicated methods. The signature of those methods will define how your API can be called via HTTP.\nThe following example shows how to define and host a service that can be used to manage an entity (books in this case).\nusing GenHTTP.Engine; using GenHTTP.Api.Protocol; using GenHTTP.Modules.Webservices; using GenHTTP.Modules.Security; using GenHTTP.Modules.Layouting; public class BookService { // GET http://localhost:8080/books/?page=1\u0026pageSize=20 [ResourceMethod] public List\u003cBook\u003e GetBooks(int page, int pageSize) { /* ... */ } // GET http://localhost:8080/books/4711 [ResourceMethod(\":id\")] public Book? GetBook(int id) { /* ... */ } // PUT http://localhost:8080/books/ [ResourceMethod(RequestMethod.PUT)] public Book AddBook(Book book) { /* ... */ } // POST http://localhost:8080/books/ [ResourceMethod(RequestMethod.POST)] public Book UpdateBook(Book book) { /* ... */ } // DELETE http://localhost:8080/books/4711 [ResourceMethod(RequestMethod.DELETE, \":id\")] public Book? DeleteBook(int id) { /* ... */ } } var service = Layout.Create() .AddService\u003cBookService\u003e(\"books\") .Add(CorsPolicy.Permissive()); Host.Create() .Handler(service) .Development() .Console() .Run(); Further Resources The following capabilities are shared by various application frameworks:\nMethod Definitions","hosting-an-api#Hosting an API":""},"title":"Webservices"},"/documentation/content/handlers/":{"data":{"":"Handlers are responsible for analyzing HTTP requests and to serve responses to the connected client. All features available in the SDK are either provided by handlers or concerns.\nIf you would like to add an additional feature that cannot be achieved using the existing functionality to the SDK or your own web application, you may implement a custom handler instance. The following example will generate a simple text response:\npublic class CustomHandler : IHandler { public IHandler Parent { get; } public CustomHandler(IHandler parent) { Parent = parent; } public ValueTask\u003cIResponse?\u003e HandleAsync(IRequest request) { var response = request.Respond() .Content(\"Hello World\") .Type(new FlexibleContentType(ContentType.TextPlain)) .Build(); return new ValueTask\u003cIResponse?\u003e(response); } public ValueTask PrepareAsync() { // perform CPU or I/O heavy work to initialize this // handler and it's children return new ValueTask(); } public IAsyncEnumerable\u003cContentElement\u003e GetContentAsync(IRequest request) =\u003e AsyncEnumerable.Empty\u003cContentElement\u003e(); } public class CustomHandlerBuilder : IHandlerBuilder\u003cCustomHandlerBuilder\u003e { private readonly List\u003cIConcernBuilder\u003e _Concerns = new List\u003cIConcernBuilder\u003e(); public CustomHandlerBuilder Add(IConcernBuilder concern) { _Concerns.Add(concern); return this; } public IHandler Build(IHandler parent) { return Concerns.Chain(parent, _Concerns, (p) =\u003e new CustomHandler(p)); } } Host.Create() .Handler(new CustomHandlerBuilder()) .Run(); As handlers are invoked for every request handled by the server, it is usually worth it to optimize them for performance. For example, as the content served by our CustomHandler does not change depending on the request, the string resource instance could be cached by a field or property set in the constructor."},"title":"Handlers"},"/documentation/content/handlers/downloads/":{"data":{"":"Downloads allow to serve a single Resource with a fixed name to your clients. The content type of the file will automatically be determined by it’s extension.\nvar resource = Resource.FromFile(\"/var/www/documents/agb.pdf\"); layout.Add(\"agb.pdf\", Download.From(resource)) In this example, the file would be available at http://localhost:8080/agb.pdf."},"title":"Downloads"},"/documentation/content/handlers/layouting/":{"data":{"":"Layouts allow the assembly of a web application from different parts. This allows you to use different handlers for different kind of work.\nvar shop = Website.Create(); // ... var adminArea = Website.Create(); // ... var api = Layout.Create() .AddService\u003cCartResource\u003e(\"cart\"); var project = Layout.Create() .Add(\"api\", api); // e.g. http://localhost:8080/api/cart/items .Add(\"admin\", adminArea) // e.g. http://localhost:8080/admin/users .Add(shop) // e.g. http://localhost:8080/checkout .Index(Page.From(...)); "},"title":"Layouting"},"/documentation/content/handlers/listing/":{"data":{"":"The directory listing provider serves a simple web UI allowing users to browse directories and files read from a resource tree below the specified path.\nvar tree = ResourceTree.FromDirectory(\"/var/www/documents/\"); Host.Create() .Handler(DirectoryListing.From(tree)) .Run(); In this example, the listing view will be available at http://localhost:8080/. The generated view will be rendered using the template of the Website the provider is embedded into (or the server theme by default)."},"title":"Directory Browsing"},"/documentation/content/handlers/load-balancer/":{"data":{"":"Allows to distribute incoming requests to multiple nodes, either by using a reverse proxy or by redirecting the client.\nvar workers = LoadBalancer.Create() .Proxy(\"http://worker-1\") .Proxy(\"http://worker-2\"); var cdn = LoadBalancer.Create() .Redirect(\"https://cdn1.domain.com\") .Redirect(\"https://cdn2.domain.com\"); var app = Layout.Create() .Add(\"api\", workers) .Add(\"content\", cdn); If needed, the incoming request can get analyzed to determine the nodes with the highest priority that should handle the request (e.g. to prefer nodes near to the requesting client).\nLoadBalancer.Create().Proxy(..., (r) =\u003e Priority.High); Additionally, the builder accepts any IHandler instance as a node, allowing to extend the functionality where needed. For example, the following snippet would distribute the load to two different, local drives.\nLoadBalancer.Create() .Add(Resources.From(ResourceTree.FromDirectory(\"/mnt/storage1/files/\"))) .Add(Resources.From(ResourceTree.FromDirectory(\"/mnt/storage2/files/\"))); "},"title":"Load Balancer"},"/documentation/content/handlers/redirects/":{"data":{"":"The redirect provider allows to inform the client that the location of the actual resource is different than the requested URI.\nHost.Create() .Handler(Redirect.To(\"http://google.com\")) .Run(); In this example, accessing http://localhost:8080 will redirect the client to the Google search engine. By default, the HTTP status 301 (permament redirect) will be sent, which can get customized to a temporary HTTP 307 redirect.\nIf you would like to redirect the client to a resource that is hosted by your application, you can also pass a symbolic route such as {sitemap} (see routing)."},"title":"Redirects"},"/documentation/content/handlers/reverse-proxy/":{"data":{"":"The reverse proxy content provider allows to embed content from another web server into your application. Content returned by the upstream server will not be embedded into a templated page.\nHost.Create() .Handler(ReverseProxy.Create().Upstream(\"http://my-cdn:8080/\")) .Run(); When running this example, any request to http://localhost:8080 will be proxied to http://my-cdn:8080/.\nIf the upstream server is either not available or does not respond in time, the provider will return a HTTP 502/504 error page instead."},"title":"Reverse Proxies"},"/documentation/content/handlers/static-content/":{"data":{"":"To provide static resources required by your web application, add them to your project and mark them either as Content or as an Embedded Resource. To serve those files, you can use the Resources factory class:\nvar layout = Layout.Create(); // serve all embedded resources in the \"Resources\" sub folder of your project var tree = ResourceTree.FromAssembly(\"Resources\"); // serve all files in the given folder var tree = ResourceTree.FromDirectory(\"./Resources\"); layout.Add(\"res\", Resources.From(tree)); Host.Create() .Handler(layout) .Run(); For example, a stylesheet named main.css in the styles subfolder would be made available at http://localhost:8080/res/styles/main.css. To generate a relative link to the file, use the routing functionality from within your template:\n{{ route 'res/styles/main.css' }} "},"title":"Static Resources"},"/documentation/content/handlers/virtual-hosts/":{"data":{"":"The virtual host handler can be used to deliver different content depending on the host requested by the client. Note, that the handler can be used anywhere in the handler chain, but usually it is most benefitial as the main handler.\nvar hosts = VirtualHosts.Create() .Add(\"domain1.com\", Layout.Create()) .Add(\"domain2.com\", Layout.Create()) .Default(Layout.Create()); Host.Create() .Handler(hosts) .Run(); The default route will be taken, if either the client did not send a host header, or the given host is not registered as a virtual host. The default route can be omitted, resuling in HTTP 404 error pages being returned by the server in such cases."},"title":"Virtual Hosts"},"/documentation/content/templates/":{"data":{"":"","updating-templates#Updating Templates":"Templates allow to create new projects based on the GenHTTP SDK (such as webservices or websites) in a couple of minutes. To install the project templates in your environment run the following command in your terminal:\ndotnet new -i GenHTTP.Templates After the templates have been installed, new projects can be created using the following commands:\nmkdir AppName cd AppName dotnet new \u003ctemplate-name\u003e If installed, the templates will also show up in Visual Studio and can be used from there to quickly create new projects:\nThe following templates are available to be used:\nTemplate Description genhttp-webservice A project that will host a new REST web service. genhttp-webservice-minimal A project that will host a minimal web service in a single file using the functional module. genhttp-website-static Serves a static website from the file system. genhttp-spa Serves the distribution files of a Single Page Application (SPA). After creating the project, you can run it with dotnet run which make the application available on http://localhost:8080.\nUpdating Templates To update your locally installed project templates, run the following command in your terminal:\ndotnet new update "},"title":"Templates"},"/documentation/hosting/":{"data":{"":"","building-template-apps#Building Template Apps":"","creating-a-new-dockerfile#Creating a new Dockerfile":"","hosting-with-docker#Hosting with Docker":"","managing-dependencies#Managing dependencies":"Hosting with Docker Docker allows to build, package and run your applications developed with GenHTTP on any server, whether it is on your NAS at home or a Kubernetes cluster in the cloud.\nAs GenHTTP is built on top of .NET, we can use the base images provided by Microsoft to setup our build chain. For a list of available base images, see their Docker Hub page.\nBuilding Template Apps If you created your application using a project template, you will see that matching Docker files have already been created. Building and running your app is as easy as:\n# creates an image named \"myproject\" docker build -f Dockerfile.linux-x64 -t myproject . # runs your application docker run -p 8080:8080 -d myproject You should be able to access your app via http://localhost:8080. If you run those commands on the machine you would like to host your application on (e.g. a Linux server) you will not need to install the .NET SDK or any other dependencies besides Docker itself.\nCreating a new Dockerfile If you did not use a project template, create a new file named Dockerfile in the root directory of your repository. The following example is for an x64 image running on Linux:\nFROM mcr.microsoft.com/dotnet/sdk:8.0-alpine AS build WORKDIR /source # copy csproj and restore as distinct layers COPY Project/*.csproj . RUN dotnet restore -r linux-musl-x64 # copy and publish app and libraries COPY Project/ . RUN dotnet publish -c release -o /app -r linux-musl-x64 --no-restore /p:PublishTrimmed=true /p:TrimMode=Link # final stage/image FROM mcr.microsoft.com/dotnet/runtime-deps:8.0-alpine-amd64 WORKDIR /app COPY --from=build /app . ENTRYPOINT [\"./Project\"] EXPOSE 8080 This assumes that you named your project Project. With this file you can use the commands in the previous section to build and run your project.\nManaging dependencies Typically your web application will have some dependencies such as databases or a redis server. docker compose allows you to define and maintain the whole infrastructure needed by your app in a single file."},"title":"Hosting"},"/documentation/server/":{"data":{"":"","extensibility#Extensibility":"As a basic requirement, the server always needs a handler to be supplied to serve incoming requests. See the Providing Content section to get a list of suitable handlers.\nServer instances are usually created using the Host factory. Depending on your use case, you can either use a blocking or non-blocking call.\n// the content we would like to serve var content = Content.From(\"Hello World!\"); // blocking until the application receives a shutdown signal (e.g. main method of a standalone application) return Host.Create() .Handler(content) .Defaults() .Run(); // non-blocking (e.g. for in-process embedding or test libraries) var host = Host.Create() .Handler(content) .Defaults() .Start(); try { // do something with the server instance } finally { // release resources host.Stop(); } The server will start to listen for requests as soon as the Run or Start method is called. When disposed, the server will stop to process messages and release all claimed resources. This way, server instances can easily be used for service mocks in integration and component testing as well.\nBy default, the server will listen to all IP addresses on port 8080. These settings can be adjusted as needed. The Defaults() call adds typical features such as compression and client caching.\nSecurity By default, the server will provide an HTTP endpoint on port 8080 with no SSL supported enabled. It is recommended to serve all of your web applications by a dedicated reverse proxy such as nginx or the GenHTTP Gateway. Nevertheless, the server allows you to add HTTPS endpoints to your application.\nSecure Endpoints Extensibility To add additional behavior to your web application or service, you can register additional elements with your server.\nCompanions ","security#Security":""},"title":"Server Lifecycle"},"/documentation/server/companions/":{"data":{"":"","performance#Performance":"As the server is designed to require as few dependencies as possible, it will neither create log files nor log errors to the console. You can register a Companion instance that allows you to handle errors and log requests:\npublic class ConsoleCompanion : IServerCompanion { public void OnRequestHandled(IRequest request, IResponse response) { Console.Log(request.Path); } public void OnServerError(ServerErrorScope scope, IPAddress? client, Exception error) { Console.Log(error); } } If you are fine with a simple console-based logger, chain the following call to your server setup:\nvar server = Server.Create().Handler(...).Console(); Performance As companion methods are called synchronously on the thread the request is handled in, you should not perform heavy, long-running tasks in those methods."},"title":"Companions"},"/documentation/server/endpoints/":{"data":{"":"By default, the server will listen on port 8080 for incoming IPv4 or IPv6 connections on any interface. To simply change the port the server will listen on, you can use the Port directive of the builder. Please note, that hosting a server on ports below 1024 will require additional permissions on some operating systems.\nvar server = Server.Create().Handler(...).Port(80).Build(); To configure the server to listen on specific interfaces only, you can use the overload:\nvar server = Server.Create() .Handler(...) .Bind(IPAddress.Parse(\"192.168.2.10\"), 8888) .Bind(IPAddress.Parse(\"0:0:0:0:0:ffff:c0a8:20a\"), 8888) .Build(); "},"title":"Endpoints and Ports"},"/documentation/server/security/":{"data":{"":"To add a SSL secured endpoint, you may use the overload of the Bind method:\nvar certificate = new X509Certificate2(\"./mycert.pfx\"); var server = Server.Create() .Handler(...) .Bind(IPAddress.Any, 80) .Bind(IPAddress.Any, 443, certificate) .Build(); The given certificate will be used to encrypt all incoming requests with. Note, that the client expects the server to use a certificate with a CN matching the requested host name."},"title":"Adding SSL Endpoints"},"/documentation/testing/":{"data":{"":"The GenHTTP.Testing package provides an easy way to write component tests for your application using a test framework of your choice. It provides both the ability to host your project in an isolated mode as well as convenience methods to run HTTP requests against your server.\nℹ️ Projects created via project templates already feature a basic test setup. ","writing-tests#Writing Tests":"The following code shows how the TestHost can be used to spin up a server instance hosting the functionality of the app to be tested and how to run requests against this instance.\nusing GenHTTP.Testing; [TestClass] public sealed class MyTests { [TestMethod] public async Task TestMyApp() { var app = ... // setup your app here using var runner = TestHost.Run(app); using var response = await runner.GetResponseAsync(\"/some/path\"); Assert.AreEqual(HttpStatusCode.OK, response.StatusCode); } } The framework uses the HttpClient to execute requests, so that the semantics are the same, e.g. when performing POST requests with a body:\nvar request = runner.GetRequest(); request.Method = HttpMethod.Post; request.Content = new StringContent(\"My Body\"); using var response = await runner.GetResponseAsync(request); "},"title":"Testing"},"/features/":{"data":{"":"","footprint#Footprint":"","security#Security":"Server Performance In terms of raw HTTP protocol performance, the GenHTTP webserver is located in the middle segment compared to other server implementations, serving more than four million requests per second. Improving the performance of the server is an ongoing task, especially since there is currently a lot of potential to be tapped.\nsee TechEmpower Web Framework Benchmarks\nFootprint Applications developed with the GenHTTP SDK are optimized for low disk space and memory requirements. A basic application will consume about 30 MB of memory and 50 MB of disk space when running in Docker.\nSecurity The GenHTTP webserver uses the default security mechanisms that ship with .NET. This results in a good security grade of A+ as reported by SSL Labs.\nsee SSL Labs Server Test","server-performance#Server Performance":""},"title":"Features"},"/legal/":{"data":{"":"","data-privacy#Data Privacy":"Imprint Andreas Nägeli\nWaldseemüller-Str. 10, 79227 Schallstadt, Germany\nandr.naegeli@gmail.com\nIf you would like to report a bug or ask a question, please visit our GitHub page.\nData Privacy This website is intended to provide information about the GenHTTP web server project. Personal data and cookies are not required for this, but your IP address is logged by the server for the purpose of technical operation with every request sent by your browser. This information will reside on the server until it is restarted. Besides this, no other personal data will be collected.","imprint#Imprint":""},"title":"Legal"},"/links/":{"data":{"":"","genhttp-gateway#GenHTTP Gateway":"","mockh#MockH":"GenHTTP Gateway The GenHTTP Gateway is an easy to configure reverse proxy provided as a docker image on Docker Hub.\nMockH Small library based on the GenHTTP webserver allowing to mock HTTP responses for integration, component and acceptance tests of projects written in C# (or .NET in general). Available on GitHub."},"title":"Links"}}